# ptrace-iterator

This crate wraps [`nix`][nix] and [`libc`][libc] to provide an iterator that can
be used to iterate over ptrace events generated by a child process.

Note that this crate will only work on Linux, as it's heavily tied to the
specifics of Linux syscalls.

## Disclaimer

This is something I've thrown together for use in other projects, rather than
being a project I'm particularly invested in personally. As a result, I've
chosen not to release it on crates.io for the time being, but if others would
find that useful, please open an issue or discussion and I'll see about setting
up a publication pipeline.

I'm mostly interested in monitoring (but not changing) syscalls, so that's what
the API is generally geared towards at present. I'm happy to discuss possible
contributions to extend that, but I can't commit to having the time to actually
invest in anything beyond the basic monitoring present here.

## Usage

The [`read_file` test](ptrace-iterator/tests/read_file.rs) is probably the
easiest thing to look at for a complete example, but very simply:

```rust
use std::process::Command;

use ptrace_iterator::{CommandTrace, Tracer};

fn main() -> anyhow::Result<()> {
    let mut cmd = Command::new("my-proc");
    // Any other arguments, etc, to the command.

    // Configure the child process to be traced.
    cmd.traceme();

    // Spawn the child process.
    let child = cmd.spawn()?;

    // Set up the tracer.
    let mut tracer = Tracer::<()>::new(child)?;

    // Iterate over events.
    for event_result in tracer.iter() {
        let mut event = event_result?;

        // There are several event types, but we'll just grab syscall entries
        // for this example.
        match event {
            Event::SyscallEntry(ref mut event) => {
                println!("syscall: {:?}", event.syscall());

                // We could also access arguments via the methods on the
                // syscall if we wanted to.
            }
            _ => {}
        }
    }

    // At this point, the child process has exited, so we can grab the exit
    // status.
    let status = tracer.status();
    dbg!(status);

    Ok(())
}
```

## Thanks

Thanks to the [Rust Foundation][rofo] and [Alpha-Omega][ao] for supporting this
work.

[ao]: https://alpha-omega.dev/
[libc]: https://crates.io/crates/libc
[nix]: https://crates.io/crates/nix
[rofo]: https://rustfoundation.org/

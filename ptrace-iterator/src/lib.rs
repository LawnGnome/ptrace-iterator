//! This crate provides [`Tracer`], which traces another process using `ptrace`, and provides an
//! [`Iterator`] of [`Event`]s that occur within that process and its descendents.

use std::{
    fmt::Debug,
    os::unix::process::ExitStatusExt,
    process::{Child, ExitStatus},
};

use ptrace_iterator_core::nix::{
    errno::Errno,
    libc::{PTRACE_EVENT_CLONE, PTRACE_EVENT_FORK, PTRACE_EVENT_VFORK},
    sys::{
        ptrace::{self, Options},
        wait::{self, WaitStatus},
    },
    unistd::Pid,
};

pub use ptrace_iterator_attr_macro::syscall;
pub use ptrace_iterator_core::{
    self as core,
    nix::{self, libc},
    syscalls::Sysno,
};

pub use crate::{command::CommandTrace, error::Error, pid::Piddable, syscall::Syscall};
use crate::{
    event::{Event, SyscallEntry, SyscallExit, SyscallInfo, SyscallNone, SyscallSeccomp},
    pending::{Pending, PendingSyscalls},
    syscall::{Info, Op},
};

mod command;
mod error;
pub mod event;
mod pending;
mod pid;
pub mod syscall;

/// A tracer for a process and any of its descendents.
///
/// Once created, iteration over [`Event`]s uses the [`TracerIterator`] returned by
/// [`Tracer::iter`]. That iterator will terminate once the child process has exited, at which point
/// the exit status can be accessed with [`Tracer::status`].
///
/// The `UserData` type parameter specifies the type of any user data that is persisted between
/// syscall entry and exit; see [`event::SyscallEntry::set_userdata`] and
/// [`event::SyscallExit::userdata`] for more usage information.
///
/// Note that tracers are not [`Send`] nor [`Sync`]. This is due to the ptrace API being explicitly
/// tied to the specific thread that is tracing the other process.
pub struct Tracer<UserData = ()> {
    child: Child,
    status: Option<ExitStatus>,

    // This will also essentially make Tracer !Send + !Sync, which is what we want.
    pending: PendingSyscalls<UserData>,
}

impl<UserData> Tracer<UserData> {
    /// Sets up a tracer for the given PID.
    pub fn new(child: Child) -> Result<Self, Error> {
        let pid = child.into_pid();

        ptrace::setoptions(
            pid,
            Options::PTRACE_O_TRACESYSGOOD
                | Options::PTRACE_O_TRACECLONE
                | Options::PTRACE_O_TRACEFORK
                | Options::PTRACE_O_TRACEVFORK
                | Options::PTRACE_O_EXITKILL,
        )
        .map_err(|e| Error::Options { e, pid })?;

        ptrace::syscall(pid, None).map_err(|e| Error::Syscall { e, pid })?;

        Ok(Self {
            child,
            status: None,
            pending: PendingSyscalls::new(),
        })
    }

    /// Returns an iterator over the trace [`Event`]s generated by the child.
    pub fn iter(&mut self) -> TracerIterator<'_, UserData> {
        TracerIterator { tracer: self }
    }

    /// Returns the top level PID being traced.
    pub fn pid(&self) -> Pid {
        self.child.into_pid()
    }

    /// Returns the exit status of the initial child, if it has exited.
    ///
    /// Generally, you would only want to call this after the iterator returned by [`Tracer::iter`]
    /// has terminated.
    pub fn status(&self) -> Option<ExitStatus> {
        self.status
    }

    #[cfg_attr(feature = "tracing", tracing::instrument(level = "TRACE", ret, err))]
    fn next_event(&mut self) -> Result<Event<UserData>, Error> {
        Ok(
            match wait::wait().map_err(|e| Error::Wait { e, pid: self.pid() })? {
                WaitStatus::PtraceSyscall(pid) => {
                    let raw = Info::from_pid(pid)?;
                    let info = SyscallInfo {
                        arch: raw.arch,
                        instruction_pointer: raw.instruction_pointer,
                        stack_pointer: raw.stack_pointer,
                    };

                    match raw.op {
                        Op::Entry { syscall } => {
                            // Note that we don't upsert anything into self.pending here;
                            // SyscallEntry will do that in its Drop impl.
                            Event::SyscallEntry(SyscallEntry {
                                pid,
                                info,
                                syscall: Some(syscall),
                                userdata: None,
                                pending: self.pending.clone(),
                            })
                        }
                        Op::Exit { sval, is_error } => {
                            let (syscall, userdata) = match self.pending.remove(pid) {
                                Some(Pending { syscall, userdata }) => (Some(syscall), userdata),
                                _ => (None, None),
                            };

                            Event::SyscallExit(SyscallExit {
                                pid,
                                info,
                                syscall,
                                sval,
                                is_error,
                                userdata,
                            })
                        }
                        Op::Seccomp { syscall, ret_data } => {
                            Event::SyscallSeccomp(SyscallSeccomp {
                                pid,
                                info,
                                syscall,
                                ret_data,
                            })
                        }
                        Op::None => Event::SyscallNone(SyscallNone { pid, info }),
                    }
                }
                WaitStatus::Signaled(pid, signal, dumped) => Event::Signal(event::Signal {
                    pid,
                    signal,
                    dumped,
                }),
                WaitStatus::PtraceEvent(pid, signal, event)
                    if event == PTRACE_EVENT_FORK
                        || event == PTRACE_EVENT_VFORK
                        || event == PTRACE_EVENT_CLONE =>
                {
                    // We have to get the event details before asking for the next syscall.
                    let child_pid = ptrace::getevent(pid)
                        .map_err(|e| Error::GetEvent { e, pid })?
                        .into_pid();

                    Event::Clone(event::Clone {
                        child_pid,
                        pid,
                        signal,
                        event,
                    })
                }
                WaitStatus::Stopped(pid, signal) => {
                    // This probably isn't very interesting to the caller, but let's just return it
                    // anyway rather than fucking around with an internal loop.
                    Event::Stopped(event::Stopped { pid, signal })
                }
                WaitStatus::Exited(pid, status) => {
                    if pid == self.pid() {
                        self.status.replace(ExitStatus::from_raw(status));
                    }

                    Event::Exited(event::Exited { pid, status })
                }
                status => Event::Other(status),
            },
        )
    }
}

impl<UserData> Debug for Tracer<UserData> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Tracer")
            .field("pid", &self.pid())
            .field("status", &self.status)
            .finish()
    }
}

/// Iterator over the trace [`Event`]s generated by a [`Tracer`].
#[derive(Debug)]
pub struct TracerIterator<'tracer, UserData> {
    tracer: &'tracer mut Tracer<UserData>,
}

impl<'tracer, UserData> Iterator for TracerIterator<'tracer, UserData> {
    type Item = Result<Event<UserData>, Error>;

    fn next(&mut self) -> Option<Self::Item> {
        match self.tracer.next_event() {
            Ok(event) => Some(Ok(event)),
            // Since we're using wait() here, the termination condition is an ECHILD error, which
            // indicates that we don't have any children (or other descendants) to wait on.
            Err(Error::Wait {
                e: Errno::ECHILD, ..
            }) => None,
            Err(e) => Some(Err(e)),
        }
    }
}
